\chapter{内核和设备驱动编程}
\addthumb{内核和设备驱动编程}{\bf 模块}{white}{gray}

\section{实验目的}
\begin{itemize}\itemsep=-3pt
  \item 学习Linux操作系统下内核程序的编写和应用；
  \item 学习可编程接口芯片的编程控制方法。
\end{itemize}

\section{内核程序结构}
\subsection{内核模块}	
	一个内核模块至少包括两个函数:
\begin{itemize}\itemsep=-3pt
  \item 由 module\_init(function) 声明，缺省函数名为 int init\_module()，
		在装载时被调用
  \item 由 module\_exit(function) 声明，缺省函数名为 void cleanup\_module()，
		卸载模块时被调用
\end{itemize}

    2.6内核版本编译内核模块通常使用下面的Makefile：

\begin{boxedminipage}{.9\textwidth}
\lstset{language=make}
%\lstset{backgroundcolor=\color{bg}}
\begin{lstlisting}{}
# Makefile (!not makefile)
ifneq ($(KERNELRELEASE),)
obj-m       := mod_name.o
else
KDIR        := /lib/modules/`uname -r`/build
PWD         := $(shell pwd)
default:
        $(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules
endif
\end{lstlisting}
\end{boxedminipage}

执行命令``make''后生成以``.ko''为后缀的文件名。

	2.4版本下，编译一个内核模块可以用如下命令

\begin{boxedminipage}{.9\textwidth}
\begin{verbatim}
  $ gcc -Wall -DMODULE -D__KERNEL__ -DLINUX -c -O2 mod_name.c\
     -I /usr/src/linux-2.4.26/include
\end{verbatim}
\end{boxedminipage}

生成后缀名``.o''的文件，它的作用和用法跟2.6内核模块的``.ko''完全一样。

	注意，内核模块的头文件路径通常不是应用程序的头文件路径 /usr/include，
因此 gcc 编译命令不能默认地找到它们，需要用 ``--I''选项为其指定路径。
PC机上，这个路径通常是 /usr/src/linux-x.xx/include，
/lib/modules/\$(VERSION)/build/include也给出了它的链接。
系统未安装内核源码头文件将无法正常编译通过。

	内核模块不是一个可独立运行的程序，它要依赖操作系统或应用程序对其调用
才能够实现它的功能。内核的加载可以通过系统命令 insmod 完成:

\begin{boxedminipage}{.9\textwidth}
\begin{verbatim}
  $ insmod mod_name.ko 参数...
\end{verbatim}
\end{boxedminipage}

	成功加载后，可以用 lsmod 看到该内核模块。卸载内核模块用系统命令 rmmod：

\begin{boxedminipage}{.9\textwidth}
\begin{verbatim}
  $ rmmod mod_name
\end{verbatim}
\end{boxedminipage}

    由于内核模块运行于系统最高特权级，因此可以做你想做的任何事情。
\subsection{设备文件及设备驱动}
    设备文件允许进程同内核中的设备驱动通信，并且通过它们和物理设备通信。
Linux 系统中有两类设备文件，一类是字符设备，一类是块设备。设备文件由命令
``mknod''创建并被赋予一个主设备号和一个次设备号。

\begin{boxedminipage}{.9\textwidth}
\begin{verbatim}
  $ mknod device_name c MAJOR MINOR -m 666
\end{verbatim}
\end{boxedminipage}
\footnote{参数'c'表示字符设备;{\bf '-m 666'设定读写允许。由于是以root
权限建立的文件，因此普通用户无法事后修改读写属性。如果有错，只能删除重建。}}

    为实现对设备的操作，内核模块需要调用函数 register\_chrdev 在注册表中
对设备进行注册。注册函数传递一个 file\_operations 结构，包含了对设备文件的
打开、释放、读、写及I/O控制等各种操作的函数指针。这项工作通常在模块加载时
完成。模块卸载时还需要调用 unregister\_chrdev， 以释放系统资源。

\section{可编程定时器/计数器的应用}
\subsection{可编程定时器/计数器}
    早期的个人计算机中，有一片可编程的定时器/计数器 8253，作为系统的硬件时钟
设备。8253在系统中占用 40H$\sim$43H端口。三个定时器/计数器的时钟输入均为
1.19MHz，各自承担以下功能:
\begin{itemize}\itemsep=-3pt
  \item T/C0，系统的日时钟，初始化为工作方式三，计数初值0。输出接往
        可编程中断控制器 8259A 的 IR0，作为系统的计时中断信号。
  \item T/C1，动态存储器刷新时钟，初始化为工作方式二，计数初值为12H。
  \item T/C2，控制系统的扬声器，产生声音信号。它的控制端 GATE2和扬声器前
        均接有控制信号，这些控制信号来自可编程 I/O接口芯片 8255的
        PB0和 PB1。8255初始化已将B口设为方式0输出。
\end{itemize}

    主中断控制器 8259A 占用 20H 和 21H 端口，其IR2供级联次中断控制器输入。
如果存在，次中断控制器端口为 0A0H 和 0A1H。

    个人计算机为可编程并行接口 8255A 分配端口 60H$\sim$63H，初始化后A口作为
键盘输入端口，B口用于一些控制信号输出。

    目前的计算机中，尽管以上各个独立的功能芯片都已经不存在，但系统集成化后
的功能依旧保留，结构原理及编程控制方法也几乎完全一样。

    T/C0和T/C1在系统中的作用比较重要，轻易不要改动它们的设置。

\subsection{编写8253的内核模块和应用程序}
    在 8253提供的六种工作方式中，只有方式二和方式三是不需要硬件触发能产生
连续波形的方式，其中方式三的输出近似方波。我们可以利用T/C2对扬声器的控制
功能。如果T/C2产生适当频率的方波，并能将相关的开关打开，使其作用在扬声器上，
便可以听到该频率的声音。(思考：为什么不用方式二？)

    编写内核模块，直接操作扬声器相关端口，或字符设备驱动程序，供应用程序调用，
用扬声器演奏一段乐曲。

    由于内核模块运行于0级特权上，因此可以直接使用汇编指令对I/O端口操作。
(或使用内核提供的 c 语言的低级函数inb\_p()、outb\_p()等等)

    下表是可供参考的音符与频率对应关系(单位:Hz):
\begin{table}[!h]
\centering\large
\begin{tabular}{|*8{|c}||} \hline
   音符 &  1  &  2  &  3  &  4  &  5  &  6  &  7\\\hline
   低音 & 131 & 147 & 165 & 175 & 196 & 220 & 247\\
   中音 & 262 & 294 & 330 & 349 & 392 & 440 & 494\\
   高音 & 523 & 587 & 659 & 698 & 784 & 880 & 987\\\hline
\end{tabular}
\end{table}

\section{通用异步串行接口}
\subsection{UART在个人计算机中的发展}
	IBM为其第一款个人计算机(PC)配备了 8250 的串行卡。8250 没有发送/接收缓冲器，
因此其速度相对较慢。在推出 IBM-PC/AT 时选用了更高性能的芯片 16450 。它带有
一个字节的发送/接收缓冲器，并修正了旧芯片的缺陷。随着 National Semiconductor
公司推出的引脚兼容的 UART 芯片 16550A 和 16650, 使得个人计算机配置的串行
通信性能不断提高。目前的个人计算机系统不再使用单独的 UART 芯片，同其它
可编程器件一样，已被更高性能的芯片集成。从软件的角度来看，操作系统和应用
程序的操作好像单独的 UART 仍然装在串行适配卡上一样。

	在标准配置中，个人计算机串行端口的基地址为 3F8H、2F8H、3E8。对串口的
编程兼容 16550 UART 规范。一般的初始化顺序是：
\begin{enumerate}\itemsep=-3pt
  \item 将DLAB置1，写除数寄存器设置波特率。个人计算机提供给 UART 的时钟为
        1.8432MHz，波特率为 1843200/(16$\times$除数值)；
  \item 置DLAB为0，设置其工作方式(数据位、校验位等等)。
\end{enumerate}

    下面就可以对数据端口进行输入/输出操作了。根据工作方式的要求，还需要对
数据状态进行查询、错误监测以及调制解调器的控制等等。

    Linux 操作系统对串口的操作通过设备文件 /dev/ttySx 完成。

    有条件的情况下，用示波器观察异步串行数据的数据帧结构。
\section{实验内容}
\begin{itemize}\itemsep=-3pt
  \item 完成一个内核模块的编写，实现内核模块的正确加载和卸载；
  \item 建立一个虚拟的字符设备驱动程序，至少要包含读、写功能，为用户程序提供
        内核空间与用户空间的数据交换，方案及实现过程自定；
  \item 在上面的基础上完成 8253 或 UART 的驱动，与自编的应用程序结合，实现
		特定的功能(如，8253 的音乐播放，UART 的双机通信)。
\end{itemize}

\section{实验报告要求}
\begin{itemize}\itemsep=-3pt
  \item 思考：设备文件的文件名、设备名和设备号各起什么作用？
  \item 查阅参考资料，画出个人计算机系统中与定时器/计数器有关的电路连接，
		或9针/25针串行端口连接器各引脚的信号；
  \item 考虑采用8253进行硬件定时的方案(暂不用中断实现)；
  \item 思考：如果用计算机的键盘模拟琴键，实现类似电子琴的功能，还需要解决
		哪些问题？
  \item 哪些因素影响串行数据传输的可靠性？
\end{itemize}
